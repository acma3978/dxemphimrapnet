<?php defined('SYSPATH') or die('No direct script access.'); /** * Light Input Filter *  * @package: 	Light * @author:		Phan Thanh Cong <chiplove.9xpro@gmail.com> * @version:	1.1 * @release:	Oct 16, 2012*/class Light_Input {		const INT 				= 1; // integer	const UINT 				= 2; // unsigned integer	const STRING 			= 3; // string (trimmed)	const BOOLEAN 			= 4; // boolean	const DATETIME 			= 5; // unixtime	const NOHTML			= 6; // replace "<" to "&lt;" and ">" to "&gt;"	const FLOAT				= 7; // foat	const CONVERT_SIMPLE 	= 100;		const ARRAY_INT 		= 101;	const ARRAY_UINT 		= 102;	const ARRAY_STRING 		= 103;	const ARRAY_BOOLEAN 	= 104;	const ARRAY_DATETIME	= 105;	const ARRAY_NOHTML		= 106;	const ARRAY_FLOAT		= 107;	protected $_source;		protected $_cleaned_variables = array();		protected static $_DEFAULTS = array(		self::INT		=> 0,		self::UINT		=> 0,		self::STRING	=> '',		self::BOOLEAN	=> 0,		self::DATETIME	=> 0,		self::NOHTML	=> '',		self::FLOAT		=> 0,	);			public function __construct(array $source = array())	{		$this->set_source($source);	}		/**	 * Helper method to set source	 * @param	array	 * @return	void	*/	public function set_source(array $source = array())	{		$this->_source = $source;	}		/**	 * @param 	string	key in data source	 * @param	integer	data type	 * @param	boolean	use default value of the data type if key is not exist	 * @return	mixed	*/	public function filter_single($name, $data_type, $use_default_value = TRUE)	{		$cleand_variable = $this->filter(array($name => $data_type), $use_default_value);		return $cleand_variable[$name];	}			protected function _clean($source, $key, $data_type, $use_default_value = TRUE)	{		if($has_value = isset($source[$key]))		{			$data = $source[$key];		}		if($data_type < self::CONVERT_SIMPLE)		{			if( ! $has_value)			{				if( ! $use_default_value)				{					return NULL;				}					$data = NULL;			}			$return = $this->_do_clean($data, $data_type);		}		else		{			if( ! $has_value)			{				$data = array();			}			$return = array();			if(is_array($data))			{				foreach($data as $subkey => $value)				{					$return[] = $this->_clean($data, $subkey, $data_type - self::CONVERT_SIMPLE, $use_default_value);				}			}		}		return $return;	}		/**	 * @param 	array	filter options	 * @param	boolean use default value if key is not exist	 * @return 	array 	cleaned variables	*/	public function filter(array $filter_options, $use_default_value = TRUE)	{			foreach($filter_options as $key => $data_type)		{			$this->_cleaned_variables[$key] = $this->_clean($this->_source, $key, $data_type, $use_default_value);		}		return $this->_cleaned_variables;	}	public static function raw_filter($data, $data_type, $use_default_value = TRUE)	{		$input = new self(array('tmp' => $data));				return $input->filter_single('tmp', $data_type, $use_default_value);	}		/**	 * Do clean variable	 *	 * @param 	mixed 	value to clean	 * @param 	integer 	 * @param	boolean	use default value if index is not exist	 * @return 	mixed	 * @throws Light_Exception if $data_type is not defined	*/	protected function _do_clean($data, $data_type)	{		switch($data_type)		{			case self::INT:						return intval($data);									case self::UINT:						return  max(0, intval($data));						case self::STRING:				return trim(strval($data)); // trim nbsp							case self::BOOLEAN:				return in_array(strval($data), array('1', 'yes', 'y', 'true')) ? 1 : 0;							case self::DATETIME:				if( ! is_array($data))				{					$data = array();				}				$data += array(					'year'	=> 0,					'month'	=> 0,					'day'	=> 0,					'hour'	=> 0,					'minute'=> 0,					'second'=> 0,				);				$data = array_map('intval', $data);				return mktime($data['hour'], $data['minute'], $data['second'], $data['month'], $data['day'], $data['year']);								break;				case self::NOHTML:							return trim(strtr(strval($data), array('<' => '&lt;','>' => '&gt;')), "\xA0");							case self::FLOAT:				return floatval($data);				default:				throw new Light_Exception("Unknown input type in " . __METHOD__);		}		return $data;	}		public function __get($key)	{		if (array_key_exists($key, $this->_cleaned_variables))		{			return $this->_cleaned_variables[$key];		}		return NULL;	}	public function __isset($key)	{		return array_key_exists($key, $this->_cleaned_variables);	}}
<?php defined('SYSPATH') or die('No direct script access.'); /** * Light Template Engine  * the simple template engine  *  * @package: 	Light * @author:		Phan Thanh Cong <chiplove.9xpro@gmail.com> * @since		2011 * @version		1.2 - restruct * @since		Aug 27, 2012*//** * NOTE: Do not use quotes (") in condition, and for each 	Correct:		<if is="$myvar['data'] == TRUE"> ..something.. </if>	Incorrect:		<if is="$myvar["data"] == TRUE"> ..something..  </if>	  * How to use if tag ?  		 <c:if is="$myvar == 1">			Content 1		 <c:elseif is="$myvar == 2">			Content 2		 <c:else />			Content 3		 </c:if>		  * Example use foreach 		<c:each from="$array" key="$key" value="$value">			{value}		</c:each>					<c:each from="$array" value="$value">			{value}		</c:each>				 * Use <prefix:literal> tag for keeping block to original (will not compiled) */class Light_Template {		/**	 * Block name use to render html	 * 	 * @var	string	*/	private $_current_block;		protected $_data = array();		protected static $_global_data = array();	public static $var_cover 	= array('{$', '}');			/**	 * Tag prefix	 * eg: <c:if ....	 *	 * @var string	*/	public static $prefix = 'c:';	/**	 * Path of template files without views path	 * @var string	*/	public static $path = '';		/**	 * Caches compiled template to php file for quick reuse	*/	public static $caching = FALSE;			public static $cache_dir = '';			public static $minify = TRUE;			/**	 * Array template blocks [name] => template	 * @var array	*/	protected static $_template_blocks = array();		/**	 * Template blocks listed by filename 	 * [fileabc] => array('block1' => TRUE, 'block2' => TRUE);	 * @var array	*/	protected static $_file_templates = array();		/**	 * Create new Template instance	 * Read block content in template file and automatic loading if the template file is not loaded 	 * 		Light_Template::factory('block', 'file');	 *	or 	 *		Light_Template::factory('file.block');	 *		Light_Template::factory('folder/file.block');	 * Read block content if it is loaded	 * 		Light_Template::load('block');	 *	 * Block name must be unique in all templates	 * 	 * @param	string	template "file" or "file.block"	 * @return	Template instance	*/	public static function create($block, $file = NULL)	{		if(strpos($block, '.')) 		{			list($file, $block) = explode('.', $block, 2);		}		return new self($block, $file);	}		public function __construct($block, $file = NULL)	{		if($file !== NULL)		{			self::load($file);		}		if( ! isset(self::$_template_blocks[$block]))		{						// try to load template with name by block name			self::load($block);						// if block name entered by folder/folder			$temp = explode('/', $block);			$block = end($temp);			if( ! isset(self::$_template_blocks[$block]))			{				throw new Light_Exception(__METHOD__ . ': Block "' . $block . '" is not loaded');			}		}		// block use to render html		$this->_current_block = $block;	}		/**	 * Load, parse template and cache all blocks to $_template_blocks	 *	 * @param string $file - File name without extension	 * @return void	*/	public static function load($file)	{		if( ! isset(self::$_file_templates[$file]))		{			if(self::$caching AND self::_load_cache($file))			{				return;			}			self::_parse_template($file);			// write cache			if(self::$caching)			{				//self::_write_cache($file);			}		}	}		/**	 * Gets templates listed by filename => array blocklist	 * @return array	*/	public static function get_template_list()	{		return self::$_file_templates;	}		/**	 * Gets all blocks loaded	 * @return array	*/	public static function get_blocks()	{		return self::$_template_blocks;	}		/**	 * Helper method to get current block content	*/	public function get_block() 	{		return self::$_template_blocks[$this->_current_block];	}		/**	 * Render to html	 *	 * @return	string	html rendered	*/	public function render(){		extract(self::$_global_data);		extract($this->_data, EXTR_OVERWRITE);		${Light_Template_Compiler::$output_var} = '';		//$setting = error_reporting(~E_NOTICE);		eval($this->get_block());		//error_reporting($setting);		return ${Light_Template_Compiler::$output_var};	}	public function __toString(){		return $this->render();	}	/**	 * Capture the template file content	 *	 * @param string $file The file name without extension	 * @return string	HTML content of the file	*/	protected static function _capture($file){		return View::factory((empty(self::$path) ? '' : self::$path.'/').$file)->render();	}	/**	 * Load template compiled from cached file	 * 	 * @param string $file - File name without extension	 * @return boolean - FALSE if cache is not exist	*/	protected static function _load_cache($file){		$file = str_replace(array('/', '\\'), '.', $file);		if(file_exists($cache_file = self::$cache_dir . DIRECTORY_SEPARATOR . $file . '.php')) {			include $cache_file;			self::$_template_blocks = self::$_template_blocks + $blocks;			foreach(array_keys($blocks) as $block_name){				self::$_file_templates[$file][$block_name] = TRUE;			}			return TRUE;		}		return FALSE;	}		/**	 * Delete cache	 * @return void	*/	public static function delete_cache(){		$files = new DirectoryIterator(self::$cache_dir);		if($files->isWritable() !== TRUE){			throw new Light_Exception(__METHOD__ . ': Directory "' . self::$cache_dir . '" is not writeable');		}		while($files->valid()){			$name = $files->getFilename();			if ($name != '.' AND $name != '..'){				$file = new SplFileInfo($files->getRealPath());				if($file->isFile())				{					unlink($file->getRealPath());				}			}			$files->next();		}	}		/**	 * Caches template compiled to file	 * Named: file.block.php	 *	 * @param	string	file name without extension	 * @param	string	block name	*/	protected static function _write_cache($file){		$dir = new DirectoryIterator(self::$cache_dir);		/*if($dir->isWritable() !== TRUE)		{			throw new Light_Exception('Directory "' . self::$cache_dir . '" is not writeable');		}*/		$filename = str_replace(array('/', '\\'), '.', $file);		// cache is exists		if( ! file_exists($cache_file = self::$cache_dir . DIRECTORY_SEPARATOR . $filename . '.php')) {			$find_and_replace = array(				'\'' 	=> '\\\'',				'\\\\'  => '\\\\\\'			);			$phpcode = '<?php class_exists(\'Light_Template\') or die(\'No direct script access.\');' . PHP_EOL . '$blocks = array();' . PHP_EOL ;			foreach(array_keys(self::$_file_templates[$file]) as $block_name) {				$content = str_replace(array_keys($find_and_replace), $find_and_replace, self::$_template_blocks[$block_name]);				$phpcode .= "\$blocks['".$block_name."'] = '" . $content . "';\n";													$fp = fopen($cache_file, 'w');				fwrite($fp, $phpcode);				fclose($fp);			}		}	}		/**	 * Find all blocks in HTML content of the file	 *	 * @param string $file - File name without extension	 * @return void	*/	protected static function _parse_template($file){		$content = self::_capture($file);		// find all block name		$count = preg_match_all('#<!--\s*BEGIN\s*:\s*(?P<name>[\w_-]+)\s*-->#iu', $content, $matches);		for($i = $count - 1; $i >= 0; $i --) {			$name = $matches['name'][$i];						if(preg_match('#<!--\s*BEGIN\s*:\s*(?P<name>'.$name.')\s*-->(?P<content>.+?)<!--\s*END\s*:\s*'.$name.'\s*-->#isu', $content, $match)) {				// replace block to variable with name by block name				$content = str_replace($match[0], self::$var_cover[0]. $name . self::$var_cover[1], $content);					// do compile and caches				self::$_template_blocks[$name] = Light_Template_Compiler::compile($match);				self::$_file_templates[$file][$name] = TRUE;			}		}	}	/**	 * Assign global value by a reference variable	 * 	 * @return Light_Template	*/	public static function bind_global($index, &$value){		self::$_global_data[$index] =& $value;	}		/**	 * Assign global variable	 *	 * Light_Template::setGlobal('varname', $data);	 * Light_Template::setGlobal(array('varname' => $data, 'varname2' => $data2));	*/	public static function set_global($index, $value){		self::$_global_data[$index] = $value;	}		/**	 * Get value associated with $index from global data	 *	 * @param string $index	 * @return mixed - NULL if have no entry for $index	*/	public static function get_global($index){		if(array_key_exists($index, $this->_global_data)) {			return self::$_global_data[$index];		}		return NULL;	}		/**	 * Assign value by a reference variable	 * 	 * @return Light_Template	*/	public function bind($index, &$value){		$this->_data[$index] =& $value;				return $this;	}		/**	 * Set value for index, or bulk set if $index is array key-value pairs	 *	 * $template->set('varname', $data);	 * $template->set(array('varname' => $data, 'varname2' => $data2));	 *	 * @param string|array  $index	 * @parm mixed $value	 * @return Light_Template	*/	public function set($index, $value = NULL){		if(is_array($index) AND $value === NULL) {			foreach($index AS $key => $value)			{				$this->set($key, $value);			}		}		else {			$this->_data[$index] = $value;		}		return $this;	}		/**	 * Get value associated with index from data or global data	 *	 * @param string $index	 * @return mixed - NULL if have no entry for $index	*/	public function get($index){		if(array_key_exists($index, $this->_data))		{			return $this->_data[$index];		}		return self::get_global($index);	}		public function remove($index){		unset($this->_data[$index]);	}		/**	 * setter method	*/	public function __set($index, $value){		$this->set($index, $value);	}		/**	 * getter method 	*/	public function & __get($index){		return $this->get($index);	}		public function __unset($key){		$this->remove($key);	}}class Light_Template_Compiler {	/**	 * The name of the block is being compiled	 * @var string	*/	public $name;		/**	 * Contents are being compiled to PHP code	 * @var string	*/	public $content;		/**	 * Original content of the block	 * @var string	*/	public $html_original;		/**	 * output variable name	 * @var string	*/	public static $output_var = '__output';		/**	 * use <prefix:literal> tag for keeping block to original (will not compiled)	*/	protected $_literal = array();			/**	 * @param array - Includes name, content	*/	public static function compile(array $template)	{		$parser = new self($template);		return $parser->__toString();	}		/**	 * Compile block template	 * @param array - Includes name, content	*/	public function __construct(array $template)	{		$this->name 			= $template['name'];		$this->content 			= $template['content'];		$this->html_original 	= $this->content;				// do compile		$this->_compile();				// check syntax		$this->_check_syntax();				if(Light_Template::$minify)		{			$this->_minify();		}	}		/**	 * minify html	*/	protected function _minify()	{		// backup script		$_scripts = array();		$count = preg_match_all('#(<script[^>]+>)(.*?)(</script>)#is', $this->content, $matches);		for($i = 0; $i < $count; $i ++)		{			$placeholder = 'MINIFY_'.uniqid();			$element = trim($matches[2][$i]);			// trim lines			//$element = preg_replace('#^\s+|s+$#m', '', $element); 			$_scripts[$placeholder] = $matches[1][$i].$element.$matches[3][$i];		}		$this->content = str_replace($matches[0], array_keys($_scripts), $this->content);				// backup texarea		$_textareas = array();		preg_match_all('#<textarea[^>]+>.*?</textarea>#is', $this->content, $matches);		foreach($matches[0] as $element)		{			$placeholder = 'MINIFY_'.uniqid();			$_textareas[$placeholder] = $element;		}		$this->content = str_replace($matches[0], array_keys($_textareas), $this->content);				//$this->content = preg_replace(array('#^\s+|s+$#m', "#\r?\n#u"), '', $this->content);		$this->content = preg_replace('#>(\s+|s+)<#mu', '><', $this->content);		// remove html comment		$this->content = preg_replace('#<\!--.*?-->#', '', $this->content);				$this->content = str_replace(array_keys($_scripts), array_values($_scripts), $this->content);		$this->content = str_replace(array_keys($_textareas), array_values($_textareas), $this->content);	}		/**	 * Compile template vars from $this->content to PHP vars 	 * @return void	*/	protected function _compile_var()	{		$matches = self::match_vars($this->content);		foreach($matches as $match)		{			$php_var = self::convert_var($match);			$this->content = str_replace($match[0], '\' . (isset('.$php_var.') ? '.$php_var.' : \'\') . \'', $this->content);		}	}		/**	 * Convert all template vars to PHP vars	 * do not add isset wrap to vars	*/	public static function convert_vars($content)	{		$matches = self::match_vars($content);		foreach($matches as $match)		{			$content = str_replace($match[0], self::convert_var($match), $content);		}		return $content;	}	/**	 * Find all variables by template variable.	 * @return array	*/	public static function match_vars($content)	{		list($left, $right) = Light_Template::$var_cover;		preg_match_all(			'#'.preg_quote($left, '#').'(?P<name>[\w_]+)(?P<index>\.[^}]+)?'.preg_quote($right, '#').'#i', 			$content, $variables,			PREG_SET_ORDER		);		return $variables;	}		/** 	 * Convert tpl var to php var	 * @param string - tpl var	 * @return string - php var	*/	public static function convert_var(array $match)	{		if(empty($match['index']))		{			$match['index'] = '';		}		$match['index'] = trim($match['index'], '.');		$indexs = array_map('trim', explode('.', $match['index']));		$indexs = array_filter($indexs, 'strlen');				$variable = '$' . $match['name'];				if($indexs)		{			$variable .= '[\'' . implode('\'][\'', $indexs) . '\']';		}				return $variable;	}		/**	 *  @return void	*/	protected function _compile()	{		$prefix = Light_Template::$prefix;				// FIND and BACKUP literal block		$count = preg_match_all('#<' . $prefix . 'literal>(.+?)</' . $prefix . 'literal>#is', $this->content, $matches, PREG_OFFSET_CAPTURE);		for($i = 0; $i < $count; $i ++)		{			$literal_content = $matches[1][0][0];			$placeholder = 'LITERAL_' . uniqid();			$this->content = substr($this->content, 0, $matches[0][0][1]) 				. $placeholder 				. substr($this->content, $matches[0][0][1] + strlen($matches[0][0][0]));			$this->_literal[$placeholder] = $literal_content;		}				$this->content = str_replace('\'', '\\\'', $this->content);				preg_match_all('#<'.preg_quote(Light_Template::$prefix).'([a-zA-Z]+)#', $this->content, $tags);				// start compile		foreach(array_unique($tags[1]) as $tag_name)		{			if(class_exists($class = 'Light_Template_Compiler_Tag_' . $tag_name))			{				$tag = new $class;								if($tag->type == 'block')				{					$tag_open = '<' . $prefix . $tag_name;					$tag_close = '</' . $prefix . $tag_name . '>';					while(1)					{						$node = $this->content;						$offset = 0;						while( ($start_position = stripos($node, $tag_open, $offset))  !== FALSE)						{							$offset = $start_position + strlen($tag_open);						}						$node = substr($node, $offset);						$end_position = stripos($node, $tag_close);												if($offset AND $end_position === FALSE)						{							throw new Light_Exception(__METHOD__ . ': Missing closing ' . strtoupper($tag_name) . ' tag in the "' . $this->name . '" block');						}						else if($offset === 0 AND $end_position !== FALSE)						{							throw new Light_Exception(__METHOD__ . ': Missing open ' . strtoupper($tag_name) . ' tag in the "' . $this->name . '" block');						}						else if($offset === 0 AND $start_position === FALSE AND $end_position === FALSE)						{							break;						}						$node = $tag_open . substr($node, 0, $end_position) . $tag_close;						$tag->set_content($node);												$compiled = '\'; ' . $tag->compile() . ' $' . self::$output_var .' .= \'';						$this->content = str_replace($node, $compiled, $this->content);												//echo $this->content."\n\n========================================================\n\n";					}				}				else if($tag->type == 'inline')				{					preg_match_all('#<'.Light_Template::$prefix . $tag_name.'.*?/?>#i', $this->content, $matches, PREG_SET_ORDER);					foreach($matches as $match)					{						$tag->set_content($match[0]);						$compiled = '\'; ' . $tag->compile() . ' $' . Light_Template_Compiler::$output_var .' .= \'';						$this->content = str_replace($match[0], $compiled, $this->content);					}					}				else				{					throw new Light_Exception(__METHOD__ . ': Unknow the TYPE of the "' . $tag_name . '" tag');				}			}				}		// RESTORE literal		$this->content = strtr($this->content, $this->_literal);				$this->content = '$' . self::$output_var . ' .= \'' . $this->content . '\';';				// compile variable		$this->_compile_var();				$this->_check_syntax();			}	/**	 * Eval to check template syntax before use to assign variables 	 * and render template to html	 * 	 * @return boolean|void - TRUE if checking without errors. Else die(message)	*/	protected function _check_syntax()	{		$error_reporting = error_reporting(0);		$result = TRUE;				//ob_get_clean();				if(eval($this->content) === FALSE)		{			$error = error_get_last();						$result = self::error(__METHOD__, array(				'title' 	=> 'The process of compiling is failed at block "<i>' . $this->name . '</i>"',				'message' 	=> $error['message'],				'type'		=> $error['type'],				'line'		=> $error['line'],				'htmlcode'	=> $this->html_original,				'phpcode'	=> $this->content,				'cover'		=> 10,			));		}		error_reporting($error_reporting);				if($result !== TRUE)		{			echo $result;			exit;		}		return $result;	}		public static function error($method, array $error, $out = FALSE)	{		$error = array_merge(array(			'cover'		=> 0,			// cover lines			'line'		=> 0,			// error at line			'type'		=> 0,			// error type			'title'		=> 'Errors!',				'message'	=> 'Errors!',			'htmlcode'	=> '',			'phpcode'	=> '',		), $error);				$html_lines = explode(PHP_EOL, $error['htmlcode']);		$cover 	= $error['cover']; // số dòng tiến/ lùi xung quanh dòng bị lỗi		if($cover <= 0) 		{			$cover = count($html_lines);		}		$line 	= ($line = ($error['line'] - $cover)) > 0 ? $line : 0;		$stop 	= $error['line'] + $cover;					for($code = ''; $line < $stop; $line ++)		{			if( ! isset($html_lines[$line]))			{				break;			}			$html_line = htmlspecialchars($html_lines[$line]);				if($line < $error['line'] AND $line + 3 > $error['line'])			{				$html_line = '<span style="color:red">' . $html_line .'</span>';			}							$code .= '<li><span class="line">' . $line.'</span> '. $html_line . '</li>';		}				$output = '<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><title>Template Compile Errors!</title>		<style>		h1{font-weight:500;font-size:20px;margin:3px 0;}h3{margin:3px 0;font-size:16px;font-weight:normal;}		ol{background: #EEEEEE;color: #333333;font-family: Tahoma;padding:5px;}		li{background: none repeat scroll 0 0 #FFFFFF;font-family: Courier;list-style:none}		li .line {background: #EEEEEE;padding: 0 5px;}		</style></head><body><div class="wrapper">'		.'<h1><strong>'.$method.'</strong>: '.$error['title'].'</i></h1>'		.'<h3>Error: <i>'.$error['message'].'</i></h3>'		.'<h3>Type: <i>'.$error['type'].'</i></h3>'		.'<h3>Line: <i>'.$error['line'].'</i></h3>'		.'<pre><code><ol>'.$code.'</ol></code></div></pre>'		.( ! empty($error['phpcode']) ? '<div class="php">'.highlight_string('<?php '.$error['phpcode'], TRUE).'</div>' : '')		.'</body></html>';					if($out)		{			echo $output;			exit;		}		return $output;	}	public function __toString()	{		return $this->content;	}}class Light_Template_Compiler_Tag {		public $content;		public function set_content($content)	{		$this->content = $content;	}		/**	 * @return string - Compiled template	*/		public function compile()	{		throw new Light_Exception('This method must be defined in extended class');	}}class Light_Template_Compiler_Tag_Include extends Light_Template_Compiler_Tag {	public $type = 'inline';			public function compile()	{		preg_match('#<'.Light_Template::$prefix.'include\s+template="(?P<template>[^"]+)"\s*/?>#iu', $this->content, $match);		return 'eval(Light_Template::create(\''.$match['template'].'\')->get_block());';		}}class Light_Template_Compiler_Tag_If extends Light_Template_Compiler_Tag {	public $type = 'block';			/**	 * Prepare condition for using without errors	 * @param string - condition of an IF statement	 * @return string	*/	protected function _prepare_condition($condition)	{		$condition = Light_Template_Compiler::convert_vars($condition);				// find all variables and wrap they with isset() to anti E_NOTICE if it is not set		$pattern = '\$[a-z_][a-z0-9_\'\[\]]*';		preg_match_all('#' . $pattern . '#i', $condition, $matches);				$wrap_isset = array();		foreach($matches[0] as $key => $var)		{			$var_regex = preg_quote($var, '#');			// tìm các biến ko bị add thêm isset()			if( ! preg_match('#'.$var_regex.'\s*=[^=]+'				.'|!?\s*(isset|empty)\s*\(\s*'.$var_regex.'\s*\)'				.'|!\s*\(?\s*'.$var_regex.'\s*\)?#u', 				$condition))			{				$wrap_isset[$var] = 1;			}		}		// not		$condition = preg_replace('#\s*\(\s*!\s*(' . $pattern . ')\s*\)\s*#iu', ' empty($1) ', $condition);		$condition = preg_replace('#\s*!\s*\(\s*(' . $pattern . ')\s*\)\s*#iu', ' empty($1) ', $condition);		$condition = preg_replace('#\s*!\s*(' . $pattern . ')\s*#iu', ' empty($1) ', $condition);		// temp..				$condition = ( ! empty($wrap_isset) ? '(isset('.implode(') AND isset(', array_keys($wrap_isset)).')) AND ' : '') . $condition;		return $condition;	}		public function compile()	{		$prefix = Light_Template::$prefix;				$cond_attr = 'is';		$pattern = '#<'.preg_quote($prefix, '#').'if\s+'.$cond_attr.'="(?P<condition>.+?)"\s*>(?P<content>.*?)</'.preg_quote($prefix, '#').'if>#isu';		if(preg_match($pattern, $this->content, $match))		{			$condition 	= stripslashes($match['condition']);			$content 	= $match['content'];			//elseif			preg_match_all('#<'.preg_quote($prefix, '#').'elseif\s+'.$cond_attr.'="(?P<condition>.+?)"\s*>#u', $content, $elseifs, PREG_SET_ORDER);			foreach($elseifs as $elseif)			{				$elseif['condition'] = stripslashes($elseif['condition']);				$elseif['condition'] = Light_Template_Compiler::convert_vars($elseif['condition']);				$content = str_replace($elseif[0], 					'\'; } else if (' . $this->_prepare_condition($elseif['condition']) . ') { $' . Light_Template_Compiler::$output_var .' .= \'', 					$content);			}			$content = preg_replace('#<'.preg_quote($prefix, '#').'else\s*/>#u', 				'\'; } else { $' . Light_Template_Compiler::$output_var .' .= \'', 				$content, 1, $else);							if( ! empty($elseifs) AND empty($else))			{				throw new Light_Exception('Missing ELSE tags in an IF statement');			}			return 'if(' . $this->_prepare_condition($condition) . ') { $' . Light_Template_Compiler::$output_var .' .= \'' . $content . '\'; }';		}		Light_Template_Compiler::error(__METHOD__, array(			'title' 	=> 'Cannot compile the IF tag',			'message' 	=> 'IF open tag includes only ' . strtoupper($cond_attr) . ' attribute.',			'htmlcode'	=> stripslashes($this->content),		), TRUE);	}}class Light_Template_Compiler_Tag_Each extends Light_Template_Compiler_Tag {		public $type = 'block';		public function compile()	{		$prefix = Light_Template::$prefix;				$pattern = '#<'.preg_quote($prefix, '#').'each\s+from="(?P<array>[^"]+)"\s+(?:key="(?P<key>[^"]+)"\s+)?value="(?P<value>[^"]+)"\s*>'			.'(?P<content>.+?)</'.preg_quote($prefix, '#').'each>#isu';				if(preg_match($pattern, $this->content, $match))		{			extract($match);			$array	= Light_Template_Compiler::convert_vars(stripslashes($array));			$key 	= Light_Template_Compiler::convert_vars($key);			$value 	= Light_Template_Compiler::convert_vars($value);						$sentence = 'if(isset(' . $array . ') AND is_array(' . $array . ')) { ' // check if isset				.'foreach(' . $array . ' as ' . ($key ? $key . ' => ' : '') . $value . ') { '					.'$' . Light_Template_Compiler::$output_var .' .= \'' . $content . '\';'				.'}'			.'}'; // and if check						return $sentence;		}		Light_Template_Compiler::error(__METHOD__, array(			'title' 	=> 'Cannot compile the EACH tag',			'message' 	=> 'EACH tag includes only <KEY>, VALUE attributes',			'htmlcode'	=> stripslashes($this->content),		), TRUE);	}}class Light_Template_Compiler_Tag_Comment extends Light_Template_Compiler_Tag {		public $type = 'block';		public function compile()	{		return '';	}}